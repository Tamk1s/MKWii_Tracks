//MDL0 fragment shader generated by BrawlLib
//Final-SKP--Tex_0054_0_dds1_m

#version 120

//!@
//https://gamedev.stackexchange.com/questions/154854/how-do-i-implement-flat-shading-in-glsl
varying vec3 viewPosition;

struct LightFrame
{
	int enabled;
	vec3 pos;
	vec3 dir;
	
	//Diffuse light
	vec4 color;
	vec3 distCoefs;
	vec3 spotCoefs;
	
	//Specular light
	int hasSpecular;
	vec4 specColor;
	vec3 distCoefsSpec;
};

float satlf(float f)
{
	return (f < 0.0) ? 0.0 : f;
}

vec3 satlv(vec3 v)
{
	return vec3(satlf(v.x),satlf(v.y),satlf(v.z));
}

float satf(float f)
{
	return clamp(f, 0.0, 1.0);
}

vec3 satv(vec3 v)
{
	return clamp(v, vec3(0.0), vec3(1.0));
}

uniform sampler2D texture0;

uniform vec4 amb[2];
uniform vec4 clr[2];
uniform vec4 creg[3];
uniform vec4 ccreg[4];

uniform vec4 scnSetAmbLight;
uniform LightFrame scnSetLights[8];

uniform int scnFogType;
uniform float scnFogStartZ;
uniform float scnFogEndZ;
uniform vec3 scnFogColor;

varying vec3 vPosition;
varying vec3 vNormal;
varying vec4 vtxColor0;
varying vec4 vtxColor1;

void main()
{
	vec4 lightChannel0 = vec4(0.0);
	vec4 lightChannel1 = vec4(0.0);
	//Lighting Calculations
	//LightChannel0
	vec4 matColor0, lightFunc0, illum0 = vec4(1.0);
	lightFunc0 = vec4(1.0);
	matColor0 = vtxColor0;
	lightChannel0 = matColor0 * lightFunc0;
	
	vec4 uv0 = gl_TexCoord[0];
	vec4 rPrev = vec4(1.0);
	vec4 texColor;
	vec4 rasColor;
	
	
	//Shader0 Stage0
	{
		texColor = texture2D(texture0, uv0.st).rgba;
		rasColor = lightChannel0.rgba;
		
		//Color Operation
		rPrev.rgb = (vec3(0.0) + (mix(vec3(0.0),texColor.rgb,rasColor.rgb)));
		rPrev.rgb = satv(rPrev.rgb);
		
		//Alpha Operation
		rPrev.a = (0.0 + (mix(0.0,texColor.a,rasColor.a)));
		rPrev.a = satf(rPrev.a);
	}
	
	
	//SCN0 Fog
	if (scnFogType != 0)
	{
		float fogDensity = 0.0;
		float posZ = length(vPosition);
		if (posZ <= scnFogStartZ)
		{
			fogDensity = 0.0;
		}
		else if (posZ >= scnFogEndZ)
		{
			fogDensity = 1.0;
		}
		else if ((scnFogType == 2) || (scnFogType == 10))
		{
			//Linear
			fogDensity = (posZ - scnFogStartZ) / (scnFogEndZ - scnFogStartZ);
		}
		else if ((scnFogType == 4) || (scnFogType == 12))
		{
			//Exp
			fogDensity = 1.0 - exp2(-8.0 * ((posZ - scnFogStartZ) / (scnFogEndZ - scnFogStartZ)));
		}
		else if ((scnFogType == 5) || (scnFogType == 13))
		{
			//Exp^2
			fogDensity = 1.0 - exp2(-8.0 * pow((posZ - scnFogStartZ) / (scnFogEndZ - scnFogStartZ), 2.0));
		}
		else if ((scnFogType == 6) || (scnFogType == 14))
		{
			//RevExp
			fogDensity = exp2(-8.0 * ((scnFogEndZ - posZ) / (scnFogEndZ - scnFogStartZ)));
		}
		else if ((scnFogType == 7) || (scnFogType == 15))
		{
			//RevExp^2
			fogDensity = exp2(-8.0 * pow((scnFogEndZ - posZ) / (scnFogEndZ - scnFogStartZ), 2.0));
		}
		rPrev.rgb = mix(rPrev.rgb, scnFogColor, satf(fogDensity));
	}
	gl_FragColor = rPrev;
	
	//Alpha Function
	if (!((gl_FragColor.a >= 0.5019608) && (gl_FragColor.a <= 1))) discard;
	
	//!@
	vec3 xTangent = dFdx( viewPosition );
    vec3 yTangent = dFdy( viewPosition );
    vec3 faceNormal = normalize( cross( xTangent, yTangent ) );
}
